<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.18">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>blazert</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1md_README"/><ulink url="https://travis-ci.com/cstatz/blazert"><image type="html" name="https://travis-ci.com/cstatz/blazert.svg?token=MzD1bv55cBzChUswxdrj&amp;branch=develop" inline="yes"></image>
</ulink></para>
<sect1 id="index_1autotoc_md0">
<title>blazeRT</title>
<para><orderedlist>
<listitem><para><ulink url="#introduction">Introduction</ulink><orderedlist>
<listitem><para><ulink url="#contributing">Contributing</ulink></para>
</listitem><listitem><para><ulink url="#versions">Versions</ulink></para>
</listitem></orderedlist>
</para>
</listitem><listitem><para><ulink url="#features">Features</ulink></para>
</listitem><listitem><para><ulink url="#installation">Installation</ulink><orderedlist>
<listitem><para><ulink url="#dependencies">Dependencies</ulink></para>
</listitem><listitem><para><ulink url="#clone-the-repository">Clone the repository</ulink></para>
</listitem><listitem><para><ulink url="#build-and-test">Build and Test</ulink></para>
</listitem><listitem><para><ulink url="#configuration">Configuration</ulink></para>
</listitem></orderedlist>
</para>
</listitem><listitem><para><ulink url="#usage">Usage</ulink><orderedlist>
<listitem><para><ulink url="#examples">Examples</ulink></para>
</listitem><listitem><para><ulink url="#minimal-example">Minimal Examples</ulink></para>
</listitem><listitem><para><ulink url="#notes">Notes</ulink></para>
</listitem></orderedlist>
</para>
</listitem><listitem><para><ulink url="#benchmarks">Benchmarks</ulink></para>
</listitem><listitem><para><ulink url="#license">License</ulink></para>
</listitem></orderedlist>
</para>
<sect2 id="index_1autotoc_md1">
<title>Introduction</title>
<para>blazeRT is a <bold>double precision ray tracer</bold> for scientific or engineering applications derived from <ulink url="https://github.com/lighttransport/nanort">nanoRT</ulink> using blaze datatypes and written in modern C++17. blazeRTs scene interface is similar to <ulink url="https://github.com/embree/embree">embree</ulink> and intents to be a minimal effort (nearly plugin-) replacement. blazeRT should work on any system and architecture for which a recent (C++17 compatible) compiler is available.</para>
<para>We aim at providing a <bold>simple and unambiguous high-level API</bold> for the ray-traversal. We do not aim at providing backwards-compatibility (especially to older C++ standards).</para>
<para>blazeRT makes use of the the <ulink url="https://bitbucket.org/blaze-lib/blaze/src/master/">blaze</ulink> linear algebra library for its vector types. Because we rely on a well-tested and well-optimized linear algebra library (instead of using our own vector types), blazeRT can focus on the actual ray tracing algorithms. Furthermore, using types from a linear algebra library is advantageous for the subsequent development of scientific application where the vector types are needed again. blazeRT should work with any library providing these vector types as long as certain criteria are met (a minimal set of operation on these vector types).</para>
<para>blazeRT works with triangular meshes and simple primitives, but it is easy to extend blazeRT to work on polygons or more complex primitives. A template for user-defined geometries can be found <ulink url="examples/geometry_template/GEOM_TEMPLATE.h">here</ulink>. If you implement new geometries, we are more than happy to receive a pull request from you to include it in blazeRT.</para>
<para>blazeRT is tested using unit tests (whose number will increase as development progresses) as well as by comparison of rendering results to reference images. Currently the unit tests cover roughly 90% of files and 69% of lines, but in the tests we try to catch as many (fringe-) cases as possible. We try to ensure high code quality and a reproducible build experience via continuous integration. During the CI process we build the examples and the tests, which need to run successfully in order for the CI to pass. Currently, blazeRT is CI-tested on Ubuntu 18.04 and macOS with gcc and clang.</para>
<para><image type="html" name="examples/baseline/path_tracer_blaze.png" inline="yes"></image>
</para>
<para>(Rendered using the <computeroutput>path_tracer</computeroutput> example adapted from <computeroutput>nanoRT</computeroutput> and originally contributed by <ulink url="https://github.com/daseyb">daseyb</ulink>)</para>
<sect3 id="index_1autotoc_md2">
<title>Contributing</title>
<para>We appreciate all contributions from issues to pull requests.</para>
<para>For contributing, please read the contribution guide.</para>
</sect3>
<sect3 id="index_1autotoc_md3">
<title>Versions</title>
<para>The releases are based on the master branch. The release-version is tagged and follows the scheme Year.Quarter.Revision.</para>
</sect3>
</sect2>
<sect2 id="index_1autotoc_md4">
<title>Features</title>
<para><itemizedlist>
<listitem><para>[x] modern C++</para>
</listitem><listitem><para>[x] single and double precision ray tracing</para>
</listitem><listitem><para>[x] simple and unambiguous high-level scene-based API</para>
</listitem><listitem><para>[x] <ulink url="https://github.com/embree/embree">Embree</ulink> fall back for single precision floats</para>
</listitem><listitem><para>[x] using vector and matrix type from <ulink url="https://bitbucket.org/blaze-lib/blaze/src/master/">blaze</ulink> for efficient linear algebra</para>
</listitem><listitem><para>[x] currently supported geometry<itemizedlist>
<listitem><para>[x] triangular meshes</para>
</listitem><listitem><para>[x] spheres</para>
</listitem><listitem><para>[x] (finite) planes</para>
</listitem><listitem><para>[x] cylinders</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>[x] BVH accelerated ray racing</para>
</listitem><listitem><para>[ ] back-face culling (will be implemented)</para>
</listitem><listitem><para>[x] unit tests via <ulink url="https://github.com/onqtam/doctest">doctest</ulink></para>
</listitem><listitem><para>[x] documentation of the test cases in <computeroutput>test/doc</computeroutput></para>
</listitem><listitem><para>[x] benchmark (comparing <ulink url="https://github.com/embree/embree">embree</ulink>, <ulink url="https://github.com/lighttransport/nanort">nanoRT</ulink>, <ulink url="https://github.com/madmann91/bvh">madmann91/bvh</ulink> and blazeRT) via <ulink url="https://github.com/google/benchmark">google benchmark</ulink></para>
</listitem><listitem><para>[x] cmake script to aggregate the code into a single-header library (not recommended)</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="index_1autotoc_md5">
<title>Installation</title>
<para>Installation and build are tested on linux (e.g. ubuntu bionic, arch linux) and macOS. Before starting the build process please ensure all dependencies are properly installed and available to the project.</para>
<sect3 id="index_1autotoc_md6">
<title>Dependencies</title>
<para><itemizedlist>
<listitem><para>C++17 capable compiler</para>
</listitem><listitem><para>cmake (&gt;= 3.11.0)</para>
</listitem><listitem><para><ulink url="https://bitbucket.org/blaze-lib/blaze/src/master/">blaze</ulink> (&gt;= 3.7)</para>
</listitem><listitem><para><ulink url="https://github.com/embree/embree">Embree</ulink> (&gt;= 3) if <computeroutput>EMBREE_TRACING</computeroutput> fallback is desired</para>
</listitem><listitem><para><ulink url="https://github.com/onqtam/doctest">doctest</ulink> (for testing, pulled in as submodule)</para>
</listitem><listitem><para><ulink url="https://github.com/google/benchmark">google benchmark</ulink> (for running the benchmarks)</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="index_1autotoc_md7">
<title>Clone the repository</title>
<para>Clone the repository with the following command: <programlisting filename=".git"><codeline><highlight class="normal">For<sp/>the<sp/>tests<sp/>and<sp/>the<sp/>benchmarks<sp/>the<sp/>submodules<sp/>must<sp/>be<sp/>cloned<sp/>as<sp/>well:</highlight></codeline>
</programlisting></para>
<para>git submodule init git submodule update <programlisting><codeline><highlight class="normal">This<sp/>will<sp/>pull<sp/>doctest,<sp/>[nanoRT](https://github.com/lighttransport/nanort)<sp/>and<sp/>[madmann91/bvh](https://github.com/madmann91/bvh)<sp/>as<sp/>submodules.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Build<sp/>and<sp/>test</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>windows<sp/>read<sp/>this:<sp/>[building<sp/>on<sp/>windows](BUILDING_ON_WINDOWS.md)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">This<sp/>is<sp/>a<sp/>header-only<sp/>library.<sp/>No<sp/>need<sp/>to<sp/>build<sp/>anything.<sp/>Just<sp/>drop<sp/>it<sp/>in<sp/>your<sp/>source<sp/>directory<sp/>and<sp/>off<sp/>you<sp/>go.</highlight></codeline>
<codeline><highlight class="normal">The<sp/>build<sp/>step<sp/>is<sp/>solely<sp/>for<sp/>the<sp/>examples,<sp/>tests<sp/>and<sp/>the<sp/>benchmark.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">We<sp/>strictly<sp/>recommend<sp/>an<sp/>out-of-source<sp/>build<sp/>in<sp/>a<sp/>separate<sp/>directory<sp/>(here<sp/>for<sp/>simplicity<sp/>```build```)<sp/></highlight></codeline>
<codeline><highlight class="normal">Starting<sp/>in<sp/>the<sp/>source<sp/>directory<sp/>to<sp/>project<sp/>is<sp/>build<sp/>from<sp/>the<sp/>commandline<sp/>as<sp/>follows:</highlight></codeline>
<codeline><highlight class="normal">```shell<sp/>script</highlight></codeline>
<codeline><highlight class="normal">mkdir<sp/>build</highlight></codeline>
<codeline><highlight class="normal">cd<sp/>build<sp/></highlight></codeline>
<codeline><highlight class="normal">ccmake<sp/>../<sp/><sp/>#<sp/>create<sp/>cache<sp/>and<sp/>configuration</highlight></codeline>
<codeline><highlight class="normal">cmake<sp/>--build<sp/>.</highlight></codeline>
<codeline><highlight class="normal">cmake<sp/>--build<sp/>.<sp/>--<sp/>install<sp/><sp/>#<sp/>If<sp/>package<sp/>needs<sp/>to<sp/>be<sp/>installed<sp/></highlight></codeline>
<codeline><highlight class="normal">ctest<sp/><sp/>#<sp/>Runs<sp/>the<sp/>tests</highlight></codeline>
</programlisting></para>
<para><bold>For maximum performance</bold>, we recommend building with <bold>gcc</bold> which results in a 15% to 20% better performance compared to clang (on linux and macOS). The provided benchmarks might be used to tune the compilation flags for your specific system and architecture.</para>
<para><bold>A word of caution:</bold> blazeRT will compile and work with compiler optimizations enabled (up to <bold>-O3</bold>), but needs infinite-math. If your application needs fast-math, ensure that the blazeRT code path is compiled with <computeroutput>-fno-finite-math-only</computeroutput> (in case of clang). In terms of performance, in its current form there is no major runtime difference between compilation with <emphasis>-O2</emphasis> and <emphasis>-O3</emphasis>.</para>
</sect3>
<sect3 id="index_1autotoc_md8">
<title>Configuration</title>
<para>The easiest way to set the configuration variables is by using <computeroutput>ccmake</computeroutput> or pass the variables via <computeroutput>cmake ../ -D&lt;VARIABLE&gt;:&lt;TYPE&gt;=value</computeroutput>.</para>
<para><itemizedlist>
<listitem><para><computeroutput>ENABLE_OMP</computeroutput>: Enable OpenMP in examples (for traversal)</para>
</listitem><listitem><para><computeroutput>BUILD_TEST</computeroutput>: Build tests</para>
</listitem><listitem><para><computeroutput>BUILD_BENCHMARK</computeroutput>: Build the benchmarks</para>
</listitem><listitem><para><computeroutput>BUILD_EXAMPLES</computeroutput>: Build examples</para>
</listitem><listitem><para><computeroutput>EMBREE_BACKEND</computeroutput>: Use <ulink url="https://github.com/embree/embree">Embree</ulink> as single-precision floating point tracing backend</para>
</listitem><listitem><para><computeroutput>BLAZE_INCLUDE_OVERRIDE</computeroutput>: Where to find the blaze includes. Must set on windows for <ulink url="https://bitbucket.org/blaze-lib/blaze/src/master/">blaze</ulink> &lt;= 3.7</para>
</listitem></itemizedlist>
</para>
</sect3>
</sect2>
<sect2 id="index_1autotoc_md9">
<title>Usage</title>
<para>To get familiar with the usage of blazeRT, look at the provided examples and test cases. To get started quickly, checkout the minimal examples below.</para>
<para><itemizedlist>
<listitem><para>The <ulink url="blazert/scene.h">scene</ulink> API can be considered <bold>stable</bold>, while the low-level API of the <ulink url="blazert/bvh">BVH</ulink> (<computeroutput>build</computeroutput>, <computeroutput>traverse</computeroutput>, ...) are not to be considered stable as they might change when requirements change with time.</para>
</listitem><listitem><para>To control the maximum tree depth set the <computeroutput>BLAZERT_MAX_TREE_DEPTH</computeroutput> to a sensible value before including <computeroutput>blazert/blazert.h</computeroutput>. Default value is 28 which corresponds to max. 134 million leafs in the BVH (for a well-balanced tree).</para>
</listitem><listitem><para>If single-precision floating-point ray tracing with <ulink url="https://github.com/embree/embree">Embree</ulink> is desired define <computeroutput>EMBREE_TRACING</computeroutput> before including <computeroutput>blazert/blazert.h</computeroutput>. When tracing using the embree backend, vector types with an alignment of 16 bytes are needed (you have to ensure this yourself).</para>
</listitem></itemizedlist>
</para>
<para>Either prim-references, -indices or primitives are stored in the bvh-nodes. Which case is implemented depends on the prim-collection.</para>
<sect3 id="index_1autotoc_md10">
<title>Examples</title>
<para><itemizedlist>
<listitem><para>[x] <ulink url="examples/path_tracer">path tracer with randomly distributed rays</ulink> for meshed geometries with rendered output</para>
</listitem><listitem><para>[x] <ulink url="examples/renderer">deterministic path tracer for reproducibility</ulink> for meshed geometries</para>
</listitem><listitem><para>[x] <ulink url="examples/scene_mesh">path tracer based on the scene facility</ulink> of blazeRT without rendered output (define <computeroutput>EMBREE_TRACING</computeroutput> for usage of embree fallback)</para>
</listitem><listitem><para>[x] <ulink url="examples/scene_primitives">cylinder and sphere primitives</ulink> within a blazeRT scene and color-coded output</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="index_1autotoc_md11">
<title>Minimal Example</title>
<para>Example for using blazeRT can be found the the <computeroutput>examples</computeroutput> subdirectory.</para>
<para>To give you an impression of the High-Level API (adapted from <computeroutput>examples/scene_primitives</computeroutput>): <programlisting><codeline><highlight class="normal">//<sp/>snip<sp/>8&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>///<sp/>Create<sp/>the<sp/>scene<sp/>and<sp/>add<sp/>some<sp/>primitive<sp/>collections:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>blazert::Scene&lt;ft&gt;<sp/>scene;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>scene.add_cylinders(*centers,<sp/>*semi_axes_a,<sp/>*semi_axes_b,<sp/>*heights,<sp/>*rotations);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>///scene.add_spheres(<sp/>...<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>///scene.add_triangles(<sp/>...<sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>///<sp/>Commit<sp/>and<sp/>build<sp/>the<sp/>scene</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>scene.commit();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>///<sp/>Iterate<sp/>over<sp/>the<sp/>ray<sp/>directions:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>y<sp/>=<sp/>0;<sp/>y<sp/>&lt;<sp/>height;<sp/>y++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>x<sp/>=<sp/>0;<sp/>x<sp/>&lt;<sp/>width;<sp/>x++)<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>blazert::Ray&lt;ft&gt;<sp/>ray{{0.0,<sp/>5.0,<sp/>20.0},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{static_cast&lt;ft&gt;((x<sp/>/<sp/>ft(width))<sp/>-<sp/>0.5),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;ft&gt;((y<sp/>/<sp/>ft(height))<sp/>-<sp/>0.5),<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;ft&gt;(-1.)}};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>blazert::RayHit&lt;ft&gt;<sp/>rayhit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(intersect1(scene,<sp/>ray,<sp/>rayhit))<sp/>{<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>///<sp/>Do<sp/>something<sp/>useful<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>&gt;8<sp/>snip</highlight></codeline>
</programlisting></para>
</sect3>
<sect3 id="index_1autotoc_md12">
<title>Notes</title>
<para><itemizedlist>
<listitem><para>Different from nanoRT, the bvh-build is not (yet) parallelized. For meshes with 5 million triangles, blazeRT needs about 5 seconds (on our tested systems) to build the BHV and about 20 seconds for 20 million triangles. For scientific or engineering ray tracing applications the scene is usually static while ray origin and direction are varied. The computational effort is hence defined mainly by the traversal and not the build. Ray traversal can be parallelized on application level (e.g. omp for loop when iterating over the ray (-directions), please have a look at the provided examples).</para>
</listitem><listitem><para><computeroutput>BLAZERTALIGN</computeroutput> is currently unused but might be used in the future.</para>
</listitem></itemizedlist>
</para>
</sect3>
</sect2>
<sect2 id="index_1autotoc_md13">
<title>Benchmarks</title>
<para>We have included benchmarks comparing blazeRT to <ulink url="https://github.com/lighttransport/nanort">nanoRT</ulink>, <ulink url="https://github.com/embree/embree">embree</ulink> and <ulink url="https://github.com/madmann91/bvh">madmann91/bvh</ulink> for bvh build and traversal. The benchmark scene is a (triangle-) meshed sphere which which can be refined by sub-division. There are two traversal cases:<itemizedlist>
<listitem><para>A rendering case where the scene size (number of triangles) is increased (while maintaining the same dimensions) and 8192 * 8192 rays are shot at the scene in a rectangular pattern. Here we expect log scaling with the number of triangles.</para>
</listitem><listitem><para>A scientific case where the scene size as well as the number of rays are increased (a ray is shot at each vertex of the sphere mesh). This can be considered as some kind of worst cast, because every ray hits and for each ray multiple overlapping bounding boxes (and subsequent primitives) need to be tested. Here we expect linear scaling with the number of triangles.</para>
</listitem></itemizedlist>
</para>
<para>The benchmarks are run for the most recent (git-) revisions of the compared ray tracing libraries.</para>
<para><emphasis>Please take the results with a grain of salt. The measured timings heavily depend on the chosen compiler, compiler version, level of optimization, operating system, system architecture, and the way the system is used otherwise (e.g. do multiple users have concurrent access to the system). We cannot guarantee that the optimal configuration (or even api) is chosen for all benchmarked libraries. Regarding embree: we&apos;re comparing traversal or intersection routines that are similar in behaviour. That means, for embree the benchmarks are performes with single ray traversal (rtcIntersect1). This is not optimal and embree is way more powerful (leveraging all the vectorization goodness) using the streaming api (or calls to rtcIntersectN).</emphasis></para>
<para>The provided results were obtained using the following configuration:<itemizedlist>
<listitem><para>OS: linux</para>
</listitem><listitem><para>Kernel: linux-5.6.15</para>
</listitem><listitem><para>CPU: Intel i5-8250U (8) @ 3.400GHz</para>
</listitem><listitem><para>RAM 32 GB</para>
</listitem><listitem><para>L1-Cache: 32 KB</para>
</listitem><listitem><para>L2-Cache: 256 KB</para>
</listitem><listitem><para>L3-Cache: 6144 KB</para>
</listitem><listitem><para>compiler: g++-10</para>
</listitem><listitem><para>optimization flags as documented in the projects root CMakeLists.txt</para>
</listitem><listitem><para>OpenMP disabled for build and traversal</para>
</listitem></itemizedlist>
</para>
<para>The following plots show the benchmark results for the bvh build and the traversal for a realistic rendering case (not all rays hit) and for a realistic scientific rendering case (all rays hit).</para>
<para><image type="html" name="benchmarks/results/benchmark_bvh_build.png" inline="yes"></image>
 <image type="html" name="benchmarks/results/benchmark_realistic_rendering.png" inline="yes"></image>
 <image type="html" name="benchmarks/results/benchmark_realistic_scientific.png" inline="yes"></image>
</para>
</sect2>
<sect2 id="index_1autotoc_md14">
<title>License</title>
<para>blazeRT is licensed under the new <bold>BSD (3-clause) license</bold>. blazeRT is based on and inspired by <computeroutput>nanoRT.h</computeroutput> which is licensed under MIT-License. For comparability, nanoRTs <computeroutput>path_tracer</computeroutput> and madman91/bvhs <computeroutput>benchmark</computeroutput> have been adapted to blazeRT to generate a baseline for the tests and benchmarks.</para>
<para><emphasis>We decided to not extend nanoRT due to the intrusive nature of the changes that came with the introduction of the blaze datatypes. Another reason was the possibility for an enhanced maintainability if the code is not kept (and developed) in a single-header library.</emphasis></para>
<para>The examples are built around third-party libraries (e.g. <computeroutput>tiny_obj_loader</computeroutput> and <computeroutput>stb_image_write</computeroutput>) which adhere to their own respective licenses (found in the included files).</para>
<para>The rendering examples are taken from the <computeroutput>nanoRT</computeroutput> and <computeroutput>bvh</computeroutput> repos and serve as a baseline. The Lucy model included in the demo scene is taken from the Stanford 3D Scanning Repository: <ulink url="http://graphics.stanford.edu/data/3Dscanrep/">http://graphics.stanford.edu/data/3Dscanrep/</ulink> </para>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
