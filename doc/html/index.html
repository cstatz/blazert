<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blazert: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">blazert
   &#160;<span id="projectnumber">20.2.1</span>
   </div>
   <div id="projectbrief">Double precision raytracer for scientific or engineering applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">blazert Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a><a href="https://travis-ci.com/cstatz/blazert"><img src="https://travis-ci.com/cstatz/blazert.svg?token=MzD1bv55cBzChUswxdrj&amp;branch=develop" alt="Build Status" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
blazeRT</h1>
<ol type="1">
<li><a href="#introduction">Introduction</a><ol type="a">
<li><a href="#contributing">Contributing</a></li>
<li><a href="#versions">Versions</a></li>
</ol>
</li>
<li><a href="#features">Features</a></li>
<li><a href="#installation">Installation</a><ol type="a">
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#clone-the-repository">Clone the repository</a></li>
<li><a href="#build-and-test">Build and Test</a></li>
<li><a href="#configuration">Configuration</a></li>
</ol>
</li>
<li><a href="#usage">Usage</a><ol type="a">
<li><a href="#examples">Examples</a></li>
<li><a href="#minimal-example">Minimal Examples</a></li>
<li><a href="#notes">Notes</a></li>
</ol>
</li>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#license">License</a></li>
</ol>
<h2><a class="anchor" id="autotoc_md1"></a>
Introduction</h2>
<p>blazeRT is a <b>double precision ray tracer</b> for scientific or engineering applications derived from <a href="https://github.com/lighttransport/nanort">nanoRT</a> using blaze datatypes and written in modern C++17. blazeRTs scene interface is similar to <a href="https://github.com/embree/embree">embree</a> and intents to be a minimal effort (nearly plugin-) replacement. blazeRT should work on any system and architecture for which a recent (C++17 compatible) compiler is available.</p>
<p>We aim at providing a <b>simple and unambiguous high-level API</b> for the ray-traversal. We do not aim at providing backwards-compatibility (especially to older C++ standards).</p>
<p>blazeRT makes use of the the <a href="https://bitbucket.org/blaze-lib/blaze/src/master/">blaze</a> linear algebra library for its vector types. Because we rely on a well-tested and well-optimized linear algebra library (instead of using our own vector types), blazeRT can focus on the actual ray tracing algorithms. Furthermore, using types from a linear algebra library is advantageous for the subsequent development of scientific application where the vector types are needed again. blazeRT should work with any library providing these vector types as long as certain criteria are met (a minimal set of operation on these vector types).</p>
<p>blazeRT works with triangular meshes and simple primitives, but it is easy to extend blazeRT to work on polygons or more complex primitives. A template for user-defined geometries can be found <a href="examples/geometry_template/GEOM_TEMPLATE.h">here</a>. If you implement new geometries, we are more than happy to receive a pull request from you to include it in blazeRT.</p>
<p>blazeRT is tested using unit tests (whose number will increase as development progresses) as well as by comparison of rendering results to reference images. Currently the unit tests cover roughly 90% of files and 69% of lines, but in the tests we try to catch as many (fringe-) cases as possible. We try to ensure high code quality and a reproducible build experience via continuous integration. During the CI process we build the examples and the tests, which need to run successfully in order for the CI to pass. Currently, blazeRT is CI-tested on Ubuntu 18.04 and macOS with gcc and clang.</p>
<p><img src="examples/baseline/path_tracer_blaze.png" alt="image" class="inline"/></p>
<p>(Rendered using the <code>path_tracer</code> example adapted from <code>nanoRT</code> and originally contributed by <a href="https://github.com/daseyb">daseyb</a>)</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Contributing</h3>
<p>We appreciate all contributions from issues to pull requests.</p>
<p>For contributing, please read the contribution guide.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Versions</h3>
<p>The releases are based on the master branch. The release-version is tagged and follows the scheme Year.Quarter.Revision.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Features</h2>
<ul>
<li>[x] modern C++</li>
<li>[x] single and double precision ray tracing</li>
<li>[x] simple and unambiguous high-level scene-based API</li>
<li>[x] <a href="https://github.com/embree/embree">Embree</a> fall back for single precision floats</li>
<li>[x] using vector and matrix type from <a href="https://bitbucket.org/blaze-lib/blaze/src/master/">blaze</a> for efficient linear algebra</li>
<li>[x] currently supported geometry<ul>
<li>[x] triangular meshes</li>
<li>[x] spheres</li>
<li>[x] (finite) planes</li>
<li>[x] cylinders</li>
</ul>
</li>
<li>[x] BVH accelerated ray racing</li>
<li>[ ] back-face culling (will be implemented)</li>
<li>[x] unit tests via <a href="https://github.com/onqtam/doctest">doctest</a></li>
<li>[x] documentation of the test cases in <code>test/doc</code></li>
<li>[x] benchmark (comparing <a href="https://github.com/embree/embree">embree</a>, <a href="https://github.com/lighttransport/nanort">nanoRT</a>, <a href="https://github.com/madmann91/bvh">madmann91/bvh</a> and blazeRT) via <a href="https://github.com/google/benchmark">google benchmark</a></li>
<li>[x] cmake script to aggregate the code into a single-header library (not recommended)</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Installation</h2>
<p>Installation and build are tested on linux (e.g. ubuntu bionic, arch linux) and macOS. Before starting the build process please ensure all dependencies are properly installed and available to the project.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Dependencies</h3>
<ul>
<li>C++17 capable compiler</li>
<li>cmake (&gt;= 3.11.0)</li>
<li><a href="https://bitbucket.org/blaze-lib/blaze/src/master/">blaze</a> (&gt;= 3.7)</li>
<li><a href="https://github.com/embree/embree">Embree</a> (&gt;= 3) if <code>EMBREE_TRACING</code> fallback is desired</li>
<li><a href="https://github.com/onqtam/doctest">doctest</a> (for testing, pulled in as submodule)</li>
<li><a href="https://github.com/google/benchmark">google benchmark</a> (for running the benchmarks)</li>
</ul>
<h3><a class="anchor" id="autotoc_md7"></a>
Clone the repository</h3>
<p>Clone the repository with the following command: </p><div class="fragment"><div class="line">For the tests and the benchmarks the submodules must be cloned as well:</div>
</div><!-- fragment --><p>git submodule init git submodule update </p><div class="fragment"><div class="line">This will pull doctest, [nanoRT](https://github.com/lighttransport/nanort) and [madmann91/bvh](https://github.com/madmann91/bvh) as submodules.</div>
<div class="line"> </div>
<div class="line">### Build and test</div>
<div class="line"> </div>
<div class="line">For windows read this: [building on windows](BUILDING_ON_WINDOWS.md)</div>
<div class="line"> </div>
<div class="line">This is a header-only library. No need to build anything. Just drop it in your source directory and off you go.</div>
<div class="line">The build step is solely for the examples, tests and the benchmark.</div>
<div class="line"> </div>
<div class="line">We strictly recommend an out-of-source build in a separate directory (here for simplicity ```build```) </div>
<div class="line">Starting in the source directory to project is build from the commandline as follows:</div>
<div class="line">```shell script</div>
<div class="line">mkdir build</div>
<div class="line">cd build </div>
<div class="line">ccmake ../  # create cache and configuration</div>
<div class="line">cmake --build .</div>
<div class="line">cmake --build . -- install  # If package needs to be installed </div>
<div class="line">ctest  # Runs the tests</div>
</div><!-- fragment --><p><b>For maximum performance</b>, we recommend building with <b>gcc</b> which results in a 15% to 20% better performance compared to clang (on linux and macOS). The provided benchmarks might be used to tune the compilation flags for your specific system and architecture.</p>
<p><b>A word of caution:</b> blazeRT will compile and work with compiler optimizations enabled (up to <b>-O3</b>), but needs infinite-math. If your application needs fast-math, ensure that the blazeRT code path is compiled with <code>-fno-finite-math-only</code> (in case of clang). In terms of performance, in its current form there is no major runtime difference between compilation with <em>-O2</em> and <em>-O3</em>.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Configuration</h3>
<p>The easiest way to set the configuration variables is by using <code>ccmake</code> or pass the variables via <code>cmake ../ -D&lt;VARIABLE&gt;:&lt;TYPE&gt;=value</code>.</p>
<ul>
<li><code>ENABLE_OMP</code>: Enable OpenMP in examples (for traversal)</li>
<li><code>BUILD_TEST</code>: Build tests</li>
<li><code>BUILD_BENCHMARK</code>: Build the benchmarks</li>
<li><code>BUILD_EXAMPLES</code>: Build examples</li>
<li><code>EMBREE_BACKEND</code>: Use <a href="https://github.com/embree/embree">Embree</a> as single-precision floating point tracing backend</li>
<li><code>BLAZE_INCLUDE_OVERRIDE</code>: Where to find the blaze includes. Must set on windows for <a href="https://bitbucket.org/blaze-lib/blaze/src/master/">blaze</a> &lt;= 3.7</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Usage</h2>
<p>To get familiar with the usage of blazeRT, look at the provided examples and test cases. To get started quickly, checkout the minimal examples below.</p>
<ul>
<li>The <a href="blazert/scene.h">scene</a> API can be considered <b>stable</b>, while the low-level API of the <a href="blazert/bvh">BVH</a> (<code>build</code>, <code>traverse</code>, ...) are not to be considered stable as they might change when requirements change with time.</li>
<li>To control the maximum tree depth set the <code>BLAZERT_MAX_TREE_DEPTH</code> to a sensible value before including <code>blazert/blazert.h</code>. Default value is 28 which corresponds to max. 134 million leafs in the BVH (for a well-balanced tree).</li>
<li>If single-precision floating-point ray tracing with <a href="https://github.com/embree/embree">Embree</a> is desired define <code>EMBREE_TRACING</code> before including <code>blazert/blazert.h</code>. When tracing using the embree backend, vector types with an alignment of 16 bytes are needed (you have to ensure this yourself).</li>
</ul>
<p>Either prim-references, -indices or primitives are stored in the bvh-nodes. Which case is implemented depends on the prim-collection.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Examples</h3>
<ul>
<li>[x] <a href="examples/path_tracer">path tracer with randomly distributed rays</a> for meshed geometries with rendered output</li>
<li>[x] <a href="examples/renderer">deterministic path tracer for reproducibility</a> for meshed geometries</li>
<li>[x] <a href="examples/scene_mesh">path tracer based on the scene facility</a> of blazeRT without rendered output (define <code>EMBREE_TRACING</code> for usage of embree fallback)</li>
<li>[x] <a href="examples/scene_primitives">cylinder and sphere primitives</a> within a blazeRT scene and color-coded output</li>
</ul>
<h3><a class="anchor" id="autotoc_md11"></a>
Minimal Example</h3>
<p>Example for using blazeRT can be found the the <code>examples</code> subdirectory.</p>
<p>To give you an impression of the High-Level API (adapted from <code>examples/scene_primitives</code>): </p><div class="fragment"><div class="line">// snip 8&lt;</div>
<div class="line">  </div>
<div class="line">  /// Create the scene and add some primitive collections:</div>
<div class="line">  blazert::Scene&lt;ft&gt; scene;</div>
<div class="line">  scene.add_cylinders(*centers, *semi_axes_a, *semi_axes_b, *heights, *rotations);</div>
<div class="line">  ///scene.add_spheres( ... );</div>
<div class="line">  ///scene.add_triangles( ... );</div>
<div class="line">  </div>
<div class="line">  /// Commit and build the scene</div>
<div class="line">  scene.commit();</div>
<div class="line">  </div>
<div class="line">  /// Iterate over the ray directions:</div>
<div class="line">  for (int y = 0; y &lt; height; y++) {</div>
<div class="line">    for (int x = 0; x &lt; width; x++) {</div>
<div class="line"> </div>
<div class="line">      const blazert::Ray&lt;ft&gt; ray{{0.0, 5.0, 20.0}, </div>
<div class="line">                                {static_cast&lt;ft&gt;((x / ft(width)) - 0.5),</div>
<div class="line">                                 static_cast&lt;ft&gt;((y / ft(height)) - 0.5), </div>
<div class="line">                                 static_cast&lt;ft&gt;(-1.)}};</div>
<div class="line">      blazert::RayHit&lt;ft&gt; rayhit;</div>
<div class="line">      </div>
<div class="line">      if (intersect1(scene, ray, rayhit)) { </div>
<div class="line">        /// Do something useful ...</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">// &gt;8 snip</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
Notes</h3>
<ul>
<li>Different from nanoRT, the bvh-build is not (yet) parallelized. For meshes with 5 million triangles, blazeRT needs about 5 seconds (on our tested systems) to build the BHV and about 20 seconds for 20 million triangles. For scientific or engineering ray tracing applications the scene is usually static while ray origin and direction are varied. The computational effort is hence defined mainly by the traversal and not the build. Ray traversal can be parallelized on application level (e.g. omp for loop when iterating over the ray (-directions), please have a look at the provided examples).</li>
<li><code>BLAZERTALIGN</code> is currently unused but might be used in the future.</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Benchmarks</h2>
<p>We have included benchmarks comparing blazeRT to <a href="https://github.com/lighttransport/nanort">nanoRT</a>, <a href="https://github.com/embree/embree">embree</a> and <a href="https://github.com/madmann91/bvh">madmann91/bvh</a> for bvh build and traversal. The benchmark scene is a (triangle-) meshed sphere which which can be refined by sub-division. There are two traversal cases:</p><ul>
<li>A rendering case where the scene size (number of triangles) is increased (while maintaining the same dimensions) and 8192 * 8192 rays are shot at the scene in a rectangular pattern. Here we expect log scaling with the number of triangles.</li>
<li>A scientific case where the scene size as well as the number of rays are increased (a ray is shot at each vertex of the sphere mesh). This can be considered as some kind of worst cast, because every ray hits and for each ray multiple overlapping bounding boxes (and subsequent primitives) need to be tested. Here we expect linear scaling with the number of triangles.</li>
</ul>
<p>The benchmarks are run for the most recent (git-) revisions of the compared ray tracing libraries.</p>
<p><em>Please take the results with a grain of salt. The measured timings heavily depend on the chosen compiler, compiler version, level of optimization, operating system, system architecture, and the way the system is used otherwise (e.g. do multiple users have concurrent access to the system). We cannot guarantee that the optimal configuration (or even api) is chosen for all benchmarked libraries. Regarding embree: we're comparing traversal or intersection routines that are similar in behaviour. That means, for embree the benchmarks are performes with single ray traversal (rtcIntersect1). This is not optimal and embree is way more powerful (leveraging all the vectorization goodness) using the streaming api (or calls to rtcIntersectN).</em></p>
<p>The provided results were obtained using the following configuration:</p><ul>
<li>OS: linux</li>
<li>Kernel: linux-5.6.15</li>
<li>CPU: Intel i5-8250U (8) @ 3.400GHz</li>
<li>RAM 32 GB</li>
<li>L1-Cache: 32 KB</li>
<li>L2-Cache: 256 KB</li>
<li>L3-Cache: 6144 KB</li>
<li>compiler: g++-10</li>
<li>optimization flags as documented in the projects root CMakeLists.txt</li>
<li>OpenMP disabled for build and traversal</li>
</ul>
<p>The following plots show the benchmark results for the bvh build and the traversal for a realistic rendering case (not all rays hit) and for a realistic scientific rendering case (all rays hit).</p>
<p><img src="benchmarks/results/benchmark_bvh_build.png" alt="Benchmark BVH build" class="inline"/> <img src="benchmarks/results/benchmark_realistic_rendering.png" alt="Benchmark BVH traversal rendering" class="inline"/> <img src="benchmarks/results/benchmark_realistic_scientific.png" alt="Benchmark BVH traversal scientific" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md14"></a>
License</h2>
<p>blazeRT is licensed under the new <b>BSD (3-clause) license</b>. blazeRT is based on and inspired by <code>nanoRT.h</code> which is licensed under MIT-License. For comparability, nanoRTs <code>path_tracer</code> and madman91/bvhs <code>benchmark</code> have been adapted to blazeRT to generate a baseline for the tests and benchmarks.</p>
<p><em>We decided to not extend nanoRT due to the intrusive nature of the changes that came with the introduction of the blaze datatypes. Another reason was the possibility for an enhanced maintainability if the code is not kept (and developed) in a single-header library.</em></p>
<p>The examples are built around third-party libraries (e.g. <code>tiny_obj_loader</code> and <code>stb_image_write</code>) which adhere to their own respective licenses (found in the included files).</p>
<p>The rendering examples are taken from the <code>nanoRT</code> and <code>bvh</code> repos and serve as a baseline. The Lucy model included in the demo scene is taken from the Stanford 3D Scanning Repository: <a href="http://graphics.stanford.edu/data/3Dscanrep/">http://graphics.stanford.edu/data/3Dscanrep/</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
